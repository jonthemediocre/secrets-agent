#!/usr/bin/env python3
"""
Test suite for VANTA Format Adapters

Tests the conversion of VANTA rules to different tool formats.
"""

import pytest
import json
import yaml
from pathlib import Path
from unittest.mock import Mock

import sys
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from vanta_format_adapters import (
    FormatAdapterFactory, CursorAdapter, ValeAdapter, ESLintAdapter,
    PrettierAdapter, GitHooksAdapter, EditorConfigAdapter, convert_rules_to_format
)
from vanta_global_rules import ResolvedRule, RuleFormat

class TestFormatAdapterFactory:
    """Test the format adapter factory"""

    def test_supported_tools(self):
        """Test that all expected tools are supported"""
        supported = FormatAdapterFactory.get_supported_tools()
        expected_tools = [
            "cursor", "vale", "eslint", "prettier", "git-hooks", "editorconfig"
        ]
        
        for tool in expected_tools:
            assert tool in supported

    def test_create_adapters(self):
        """Test creating each type of adapter"""
        for tool in FormatAdapterFactory.get_supported_tools():
            adapter = FormatAdapterFactory.create_adapter(tool)
            assert adapter is not None
            assert hasattr(adapter, 'convert')
            assert hasattr(adapter, 'get_file_extension')

    def test_unsupported_tool_error(self):
        """Test that unsupported tools raise appropriate error"""
        with pytest.raises(ValueError) as exc_info:
            FormatAdapterFactory.create_adapter("unsupported_tool")
        
        assert "Unsupported tool" in str(exc_info.value)

class TestCursorAdapter:
    """Test Cursor IDE format adapter"""

    @pytest.fixture
    def cursor_adapter(self):
        return FormatAdapterFactory.create_adapter("cursor")

    @pytest.fixture
    def sample_rules(self):
        return [
            ResolvedRule(
                original_path=".cursor/rules/python.mdc",
                format=RuleFormat.MDC,
                content="""# RULE TYPE: Always
# FILE PATTERNS: **/*.py

## Python Standards
- Use type hints
- Follow PEP 8 formatting
- Add docstrings to functions""",
                includes=[],
                metadata={}
            ),
            ResolvedRule(
                original_path=".cursor/rules/general.md",
                format=RuleFormat.MARKDOWN,
                content="""# General Development Rules

## Code Quality
- Write clear, readable code
- Add meaningful comments
- Test your code""",
                includes=[],
                metadata={}
            )
        ]

    def test_cursor_conversion(self, cursor_adapter, sample_rules):
        """Test conversion to Cursor format"""
        result = cursor_adapter.convert(sample_rules)
        
        assert "# Cursor IDE Rules" in result
        assert "Auto-generated by VANTA Global Rules System" in result
        assert "## python" in result
        assert "## general" in result
        assert "Use type hints" in result
        assert "Write clear, readable code" in result

    def test_mdc_to_cursor_conversion(self, cursor_adapter):
        """Test specific MDC to Cursor conversion logic"""
        mdc_content = """# RULE TYPE: Always
# FILE PATTERNS: **/*.py

## Python Rules
Content here"""
        
        converted = cursor_adapter._convert_mdc_to_cursor(mdc_content)
        
        assert "**Rule Type:** Always" in converted
        assert "**File Patterns:** `**/*.py`" in converted
        assert "## Python Rules" in converted

    def test_file_extension(self, cursor_adapter):
        """Test file extension for Cursor format"""
        assert cursor_adapter.get_file_extension() == ".md"

class TestValeAdapter:
    """Test Vale linter format adapter"""

    @pytest.fixture
    def vale_adapter(self):
        return FormatAdapterFactory.create_adapter("vale")

    @pytest.fixture
    def mdc_rules(self):
        return [
            ResolvedRule(
                original_path="rules/style.mdc",
                format=RuleFormat.MDC,
                content="""# RULE TYPE: Always
# FILE PATTERNS: **/*.md

## Writing Style
Avoid using passive voice. Use active voice instead.
Forbidden words: `utilize` should be `use`.""",
                includes=[],
                metadata={}
            )
        ]

    def test_vale_conversion(self, vale_adapter, mdc_rules):
        """Test conversion to Vale format"""
        result = vale_adapter.convert(mdc_rules)
        
        # Parse the YAML result
        parsed = yaml.safe_load(result)
        
        assert "config" in parsed
        assert "styles" in parsed
        assert "StylesPath" in parsed["config"]
        assert "VANTA" in parsed["styles"]

    def test_mdc_to_vale_conversion(self, vale_adapter):
        """Test MDC to Vale rule conversion"""
        mdc_content = """# RULE TYPE: Always
# FILE PATTERNS: **/*.md

Avoid using forbidden patterns like `bad_pattern`."""
        
        vale_rule = vale_adapter._convert_mdc_to_vale(mdc_content, "test_rule")
        
        assert vale_rule is not None
        assert "message" in vale_rule
        assert "level" in vale_rule

    def test_file_extension(self, vale_adapter):
        """Test file extension for Vale format"""
        assert vale_adapter.get_file_extension() == ".yaml"

class TestESLintAdapter:
    """Test ESLint format adapter"""

    @pytest.fixture
    def eslint_adapter(self):
        return FormatAdapterFactory.create_adapter("eslint")

    @pytest.fixture
    def json_rules(self):
        return [
            ResolvedRule(
                original_path="rules/javascript.json",
                format=RuleFormat.JSON,
                content='{"eslint": {"semi": ["error", "always"], "quotes": ["error", "single"]}}',
                includes=[],
                metadata={}
            )
        ]

    def test_eslint_conversion(self, eslint_adapter, json_rules):
        """Test conversion to ESLint format"""
        result = eslint_adapter.convert(json_rules)
        
        # Parse the JSON result
        parsed = json.loads(result)
        
        assert "extends" in parsed
        assert "rules" in parsed
        assert "semi" in parsed["rules"]
        assert "quotes" in parsed["rules"]

    def test_file_extension(self, eslint_adapter):
        """Test file extension for ESLint format"""
        assert eslint_adapter.get_file_extension() == ".json"

class TestPrettierAdapter:
    """Test Prettier format adapter"""

    @pytest.fixture
    def prettier_adapter(self):
        return FormatAdapterFactory.create_adapter("prettier")

    @pytest.fixture
    def formatting_rules(self):
        return [
            ResolvedRule(
                original_path="rules/formatting.md",
                format=RuleFormat.MARKDOWN,
                content="""# Formatting Rules

Use single quotes for strings.
Line width should be 120 characters.
Semicolons are required.""",
                includes=[],
                metadata={}
            )
        ]

    def test_prettier_conversion(self, prettier_adapter, formatting_rules):
        """Test conversion to Prettier format"""
        result = prettier_adapter.convert(formatting_rules)
        
        # Parse the JSON result
        parsed = json.loads(result)
        
        assert "semi" in parsed
        assert "singleQuote" in parsed
        assert "printWidth" in parsed
        
        # Check extracted values
        assert parsed["singleQuote"] == True
        assert parsed["printWidth"] == 120

    def test_file_extension(self, prettier_adapter):
        """Test file extension for Prettier format"""
        assert prettier_adapter.get_file_extension() == ".json"

class TestGitHooksAdapter:
    """Test Git Hooks format adapter"""

    @pytest.fixture
    def git_adapter(self):
        return FormatAdapterFactory.create_adapter("git-hooks")

    @pytest.fixture
    def git_rules(self):
        return [
            ResolvedRule(
                original_path="rules/git.md",
                format=RuleFormat.MARKDOWN,
                content="""# Git Rules

All commit messages must follow conventional format.
Code must be pushed only after review.
Run tests before commit.""",
                includes=[],
                metadata={}
            )
        ]

    def test_git_hooks_conversion(self, git_adapter, git_rules):
        """Test conversion to Git hooks format"""
        result = git_adapter.convert(git_rules)
        
        assert "#!/bin/bash" in result
        assert "Git hooks generated by VANTA Global Rules" in result
        assert "PRE-COMMIT HOOK" in result or "COMMIT-MSG HOOK" in result

    def test_file_extension(self, git_adapter):
        """Test file extension for Git hooks format"""
        assert git_adapter.get_file_extension() == ".sh"

class TestEditorConfigAdapter:
    """Test EditorConfig format adapter"""

    @pytest.fixture
    def editor_adapter(self):
        return FormatAdapterFactory.create_adapter("editorconfig")

    @pytest.fixture
    def editor_rules(self):
        return [
            ResolvedRule(
                original_path="rules/editor.md",
                format=RuleFormat.MARKDOWN,
                content="""# Editor Configuration

Use 2 spaces for indentation.
Max line length is 100 characters.
Always insert final newline.""",
                includes=[],
                metadata={}
            )
        ]

    def test_editorconfig_conversion(self, editor_adapter, editor_rules):
        """Test conversion to EditorConfig format"""
        result = editor_adapter.convert(editor_rules)
        
        assert "root = true" in result
        assert "[*]" in result
        assert "indent_style = space" in result
        assert "indent_size = 2" in result
        assert "max_line_length = 100" in result

    def test_file_extension(self, editor_adapter):
        """Test file extension for EditorConfig format"""
        assert editor_adapter.get_file_extension() == ""

class TestConvertRulesToFormat:
    """Test the convenience conversion function"""

    @pytest.fixture
    def sample_rules(self):
        return [
            ResolvedRule(
                original_path="test.mdc",
                format=RuleFormat.MDC,
                content="# RULE TYPE: Always\n# FILE PATTERNS: **/*\n\nTest content",
                includes=[],
                metadata={}
            )
        ]

    def test_convert_to_cursor(self, sample_rules, tmp_path):
        """Test conversion using the convenience function"""
        output_path = tmp_path / "output.md"
        
        result = convert_rules_to_format(sample_rules, "cursor", output_path)
        
        assert "# Cursor IDE Rules" in result
        assert output_path.exists()
        assert output_path.read_text() == result

    def test_convert_without_output_path(self, sample_rules):
        """Test conversion without specifying output path"""
        result = convert_rules_to_format(sample_rules, "cursor")
        
        assert "# Cursor IDE Rules" in result
        assert isinstance(result, str)

    def test_auto_extension_handling(self, sample_rules, tmp_path):
        """Test automatic file extension handling"""
        output_path = tmp_path / "output"  # No extension
        
        convert_rules_to_format(sample_rules, "cursor", output_path)
        
        # Should add .md extension for cursor format
        expected_path = tmp_path / "output.md"
        assert expected_path.exists()

class TestAdapterErrorHandling:
    """Test error handling in adapters"""

    def test_invalid_json_in_eslint_rules(self):
        """Test handling of invalid JSON in ESLint adapter"""
        adapter = FormatAdapterFactory.create_adapter("eslint")
        
        invalid_rules = [
            ResolvedRule(
                original_path="invalid.json",
                format=RuleFormat.JSON,
                content='{"invalid": json}',  # Invalid JSON
                includes=[],
                metadata={}
            )
        ]
        
        # Should not crash, should return basic config
        result = adapter.convert(invalid_rules)
        parsed = json.loads(result)
        
        assert "extends" in parsed
        assert "rules" in parsed

    def test_empty_rules_list(self):
        """Test handling of empty rules list"""
        for tool in FormatAdapterFactory.get_supported_tools():
            adapter = FormatAdapterFactory.create_adapter(tool)
            result = adapter.convert([])
            
            # Should return valid output even with no rules
            assert isinstance(result, str)
            assert len(result) > 0

class TestAdapterIntegration:
    """Integration tests for adapters"""

    def test_all_adapters_with_mixed_formats(self):
        """Test all adapters with a mix of rule formats"""
        mixed_rules = [
            ResolvedRule(
                original_path="rule1.mdc",
                format=RuleFormat.MDC,
                content="# RULE TYPE: Always\n# FILE PATTERNS: **/*.py\n\nPython rules",
                includes=[],
                metadata={}
            ),
            ResolvedRule(
                original_path="rule2.md",
                format=RuleFormat.MARKDOWN,
                content="# General Rules\n\nGeneral development guidelines",
                includes=[],
                metadata={}
            ),
            ResolvedRule(
                original_path="rule3.yaml",
                format=RuleFormat.YAML,
                content="standards:\n  - quality\n  - performance",
                includes=[],
                metadata={}
            )
        ]
        
        # Test that all adapters can handle mixed formats
        for tool in FormatAdapterFactory.get_supported_tools():
            adapter = FormatAdapterFactory.create_adapter(tool)
            result = adapter.convert(mixed_rules)
            
            assert isinstance(result, str)
            assert len(result) > 0

if __name__ == "__main__":
    pytest.main([__file__, "-v"]) 