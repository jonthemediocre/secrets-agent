#!/usr/bin/env python3
"""
VANTA Format Adapters

FR8: Format adapters for tool-specific output
Converts VANTA rules to different tool formats (Cursor, Vale, Roo, etc.)

Author: VANTA! Coder
Version: 1.0.0
"""

import json
import yaml
import re
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from vanta_global_rules import ResolvedRule, RuleFormat

@dataclass
class AdapterConfig:
    """Configuration for format adapters"""
    tool_name: str
    output_format: str
    template_path: Optional[str] = None
    custom_mappings: Dict[str, str] = None

class FormatAdapter(ABC):
    """Base class for format adapters"""
    
    def __init__(self, config: AdapterConfig):
        self.config = config
    
    @abstractmethod
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert resolved rules to tool-specific format"""
        pass
    
    @abstractmethod
    def get_file_extension(self) -> str:
        """Get the file extension for this format"""
        pass

class CursorAdapter(FormatAdapter):
    """Adapter for Cursor IDE rules format"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to Cursor-compatible markdown format"""
        output = []
        output.append("# Cursor IDE Rules")
        output.append("")
        output.append("<!-- Auto-generated by VANTA Global Rules System -->")
        output.append("")
        
        for rule in resolved_rules:
            output.append(f"## {Path(rule.original_path).stem}")
            output.append("")
            
            # Add metadata as comments
            output.append(f"<!-- Source: {rule.original_path} -->")
            output.append(f"<!-- Format: {rule.format.value} -->")
            if rule.includes:
                output.append(f"<!-- Includes: {len(rule.includes)} files -->")
            output.append("")
            
            # Convert content based on original format
            if rule.format == RuleFormat.MDC:
                # Parse MDC structure and convert to Cursor format
                converted_content = self._convert_mdc_to_cursor(rule.content)
                output.append(converted_content)
            else:
                # Use content as-is for markdown and text
                output.append(rule.content)
            
            output.append("")
            output.append("---")
            output.append("")
        
        return "\n".join(output)
    
    def _convert_mdc_to_cursor(self, mdc_content: str) -> str:
        """Convert MDC format to Cursor-compatible format"""
        lines = mdc_content.split('\n')
        converted = []
        
        for line in lines:
            # Convert MDC headers to markdown
            if line.strip().startswith('# RULE TYPE:'):
                rule_type = line.split(':', 1)[1].strip()
                converted.append(f"**Rule Type:** {rule_type}")
            elif line.strip().startswith('# FILE PATTERNS:'):
                patterns = line.split(':', 1)[1].strip()
                converted.append(f"**File Patterns:** `{patterns}`")
            else:
                converted.append(line)
        
        return '\n'.join(converted)
    
    def get_file_extension(self) -> str:
        return ".md"

class ValeAdapter(FormatAdapter):
    """Adapter for Vale linter configuration"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to Vale configuration format"""
        vale_config = {
            "StylesPath": "styles",
            "MinAlertLevel": "suggestion",
            "Packages": [],
            "Formats": {
                "md": {"BasedOnStyles": ["VANTA"]}
            }
        }
        
        # Create VANTA style rules
        vanta_rules = {}
        
        for rule in resolved_rules:
            rule_name = Path(rule.original_path).stem
            
            # Extract rule patterns and convert to Vale format
            if rule.format == RuleFormat.MDC:
                vale_rule = self._convert_mdc_to_vale(rule.content, rule_name)
                if vale_rule:
                    vanta_rules[rule_name] = vale_rule
        
        # Create complete Vale package
        vale_package = {
            "config": vale_config,
            "styles": {
                "VANTA": vanta_rules
            }
        }
        
        return yaml.dump(vale_package, default_flow_style=False)
    
    def _convert_mdc_to_vale(self, mdc_content: str, rule_name: str) -> Optional[Dict[str, Any]]:
        """Convert MDC rule to Vale format"""
        lines = mdc_content.split('\n')
        
        # Extract patterns and rules
        file_patterns = None
        rule_type = None
        description = ""
        
        for line in lines:
            if line.strip().startswith('# FILE PATTERNS:'):
                file_patterns = line.split(':', 1)[1].strip()
            elif line.strip().startswith('# RULE TYPE:'):
                rule_type = line.split(':', 1)[1].strip()
            elif line.strip() and not line.startswith('#'):
                description += line + " "
        
        if not file_patterns:
            return None
        
        # Create Vale rule structure
        vale_rule = {
            "extends": "existence" if "forbidden" in description.lower() else "suggestion",
            "message": f"VANTA Rule: {rule_name}",
            "level": "warning",
            "scope": "text"
        }
        
        # Add patterns if applicable
        if "forbidden" in description.lower():
            # Extract forbidden patterns
            patterns = re.findall(r'`([^`]+)`', description)
            if patterns:
                vale_rule["tokens"] = patterns
        
        return vale_rule
    
    def get_file_extension(self) -> str:
        return ".yaml"

class ESLintAdapter(FormatAdapter):
    """Adapter for ESLint configuration"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to ESLint configuration format"""
        eslint_config = {
            "extends": ["@vanta/eslint-config"],
            "rules": {},
            "overrides": []
        }
        
        for rule in resolved_rules:
            if rule.format == RuleFormat.JSON:
                try:
                    rule_data = json.loads(rule.content)
                    if "eslint" in rule_data:
                        eslint_config["rules"].update(rule_data["eslint"])
                except json.JSONDecodeError:
                    continue
        
        return json.dumps(eslint_config, indent=2)
    
    def get_file_extension(self) -> str:
        return ".json"

class PrettierAdapter(FormatAdapter):
    """Adapter for Prettier configuration"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to Prettier configuration format"""
        prettier_config = {
            "semi": True,
            "trailingComma": "es5",
            "singleQuote": True,
            "printWidth": 80,
            "tabWidth": 2
        }
        
        # Extract formatting rules from resolved rules
        for rule in resolved_rules:
            if "prettier" in rule.content.lower() or "formatting" in rule.content.lower():
                # Extract formatting preferences
                if "semicolon" in rule.content.lower():
                    prettier_config["semi"] = "required" in rule.content.lower()
                if "quote" in rule.content.lower():
                    prettier_config["singleQuote"] = "single" in rule.content.lower()
                if "width" in rule.content.lower():
                    width_match = re.search(r'width[:\s]+(\d+)', rule.content.lower())
                    if width_match:
                        prettier_config["printWidth"] = int(width_match.group(1))
        
        return json.dumps(prettier_config, indent=2)
    
    def get_file_extension(self) -> str:
        return ".json"

class GitHooksAdapter(FormatAdapter):
    """Adapter for Git hooks configuration"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to Git hooks format"""
        hooks = {
            "pre-commit": [],
            "pre-push": [],
            "commit-msg": []
        }
        
        for rule in resolved_rules:
            content_lower = rule.content.lower()
            
            # Extract git-related rules
            if "commit" in content_lower:
                if "message" in content_lower or "msg" in content_lower:
                    hooks["commit-msg"].append(f"# Rule from {rule.original_path}")
                    hooks["commit-msg"].append("# Validate commit message format")
                else:
                    hooks["pre-commit"].append(f"# Rule from {rule.original_path}")
            
            if "push" in content_lower:
                hooks["pre-push"].append(f"# Rule from {rule.original_path}")
        
        # Generate shell script
        output = ["#!/bin/bash", "", "# Git hooks generated by VANTA Global Rules", ""]
        
        for hook_name, hook_rules in hooks.items():
            if hook_rules:
                output.append(f"# {hook_name.upper()} HOOK")
                output.extend(hook_rules)
                output.append("")
        
        return "\n".join(output)
    
    def get_file_extension(self) -> str:
        return ".sh"

class EditorConfigAdapter(FormatAdapter):
    """Adapter for EditorConfig format"""
    
    def convert(self, resolved_rules: List[ResolvedRule]) -> str:
        """Convert to EditorConfig format"""
        config_sections = {
            "root": "true",
            "*": {
                "charset": "utf-8",
                "end_of_line": "lf",
                "insert_final_newline": "true",
                "trim_trailing_whitespace": "true"
            }
        }
        
        # Extract editor-specific rules
        for rule in resolved_rules:
            content_lower = rule.content.lower()
            
            if "indent" in content_lower:
                if "space" in content_lower:
                    config_sections["*"]["indent_style"] = "space"
                elif "tab" in content_lower:
                    config_sections["*"]["indent_style"] = "tab"
                
                # Extract indent size
                size_match = re.search(r'(\d+)\s*space', content_lower)
                if size_match:
                    config_sections["*"]["indent_size"] = size_match.group(1)
            
            if "line length" in content_lower or "max width" in content_lower:
                width_match = re.search(r'(\d+)', content_lower)
                if width_match:
                    config_sections["*"]["max_line_length"] = width_match.group(1)
        
        # Generate .editorconfig format
        output = []
        for section, settings in config_sections.items():
            if section == "root":
                output.append(f"root = {settings}")
                output.append("")
            else:
                output.append(f"[{section}]")
                if isinstance(settings, dict):
                    for key, value in settings.items():
                        output.append(f"{key} = {value}")
                output.append("")
        
        return "\n".join(output)
    
    def get_file_extension(self) -> str:
        return ""  # .editorconfig has no extension

class FormatAdapterFactory:
    """Factory for creating format adapters"""
    
    _adapters = {
        "cursor": CursorAdapter,
        "vale": ValeAdapter,
        "eslint": ESLintAdapter,
        "prettier": PrettierAdapter,
        "git-hooks": GitHooksAdapter,
        "editorconfig": EditorConfigAdapter
    }
    
    @classmethod
    def create_adapter(cls, tool_name: str, config: Optional[AdapterConfig] = None) -> FormatAdapter:
        """Create a format adapter for the specified tool"""
        if tool_name not in cls._adapters:
            raise ValueError(f"Unsupported tool: {tool_name}. Available: {list(cls._adapters.keys())}")
        
        if config is None:
            config = AdapterConfig(tool_name=tool_name, output_format="default")
        
        return cls._adapters[tool_name](config)
    
    @classmethod
    def get_supported_tools(cls) -> List[str]:
        """Get list of supported tools"""
        return list(cls._adapters.keys())

def convert_rules_to_format(resolved_rules: List[ResolvedRule], 
                           tool_name: str, 
                           output_path: Optional[Path] = None) -> str:
    """
    Convenience function to convert rules to a specific format
    
    Args:
        resolved_rules: List of resolved rules
        tool_name: Target tool name
        output_path: Optional output file path
    
    Returns:
        Converted content as string
    """
    adapter = FormatAdapterFactory.create_adapter(tool_name)
    converted_content = adapter.convert(resolved_rules)
    
    if output_path:
        # Ensure proper file extension
        if not output_path.suffix:
            extension = adapter.get_file_extension()
            if extension:
                output_path = output_path.with_suffix(extension)
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(converted_content, encoding='utf-8')
    
    return converted_content

# Example usage and testing
if __name__ == "__main__":
    from vanta_global_rules import VantaGlobalRules
    
    # Create a test instance
    rules_system = VantaGlobalRules()
    
    # Test format adapters
    print("🔧 Testing Format Adapters")
    print(f"Supported tools: {FormatAdapterFactory.get_supported_tools()}")
    
    # Create sample resolved rules for testing
    sample_rules = [
        ResolvedRule(
            original_path=".cursor/rules/test.mdc",
            format=RuleFormat.MDC,
            content="""# RULE TYPE: Always
# FILE PATTERNS: **/*.py

## Python Code Quality
- Use descriptive variable names
- Add type hints
- Follow PEP 8 formatting
""",
            includes=[],
            metadata={}
        )
    ]
    
    # Test each adapter
    for tool in FormatAdapterFactory.get_supported_tools():
        try:
            converted = convert_rules_to_format(sample_rules, tool)
            print(f"✅ {tool}: {len(converted)} characters")
        except Exception as e:
            print(f"❌ {tool}: {e}") 