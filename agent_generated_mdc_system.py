#!/usr/bin/env python3
"""
📝 AGENT-GENERATED MDC RULES SYSTEM
==================================

Advanced system for agents to write their own .mdc rules based on context analysis.
This enables true self-governance and dynamic rule evolution.

Features:
- Context-aware rule generation
- Justification tracking
- Linked rule relationships
- Collaborative rule authoring
- Automatic rule versioning
"""

import asyncio
import yaml
import json
import time
import hashlib
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class RuleType(Enum):
    """Types of rules agents can generate"""
    SECURITY = "security"
    BACKUP = "backup"
    OPTIMIZATION = "optimization"
    GOVERNANCE = "governance"
    WORKFLOW = "workflow"
    SYMBOLIC = "symbolic"
    TRINITY = "trinity"

class RulePriority(Enum):
    """Rule priority levels"""
    CRITICAL = 100
    HIGH = 75
    MEDIUM = 50
    LOW = 25
    INFORMATIONAL = 10

@dataclass
class RuleContext:
    """Context for rule generation"""
    trigger_event: str
    risk_level: str
    detection_method: str
    affected_systems: List[str]
    mitigation_strategy: str
    justification: str
    linked_rules: List[str]
    collaboration_agents: List[str]

@dataclass
class GeneratedRule:
    """A rule generated by an agent"""
    rule_id: str
    author_agent: str
    title: str
    description: str
    rule_type: RuleType
    priority: RulePriority
    content: str
    context: RuleContext
    validation_criteria: List[str]
    evolution_triggers: List[str]
    created_at: datetime
    version: str

class AgentRuleGenerator:
    """Core rule generation engine for agents"""
    
    def __init__(self, agent_id: str, vanta_path: Path):
        self.agent_id = agent_id
        self.vanta_path = vanta_path
        self.rules_path = vanta_path / "rules" / "agent_generated"
        self.rules_path.mkdir(parents=True, exist_ok=True)
        
        # Rule templates for different types
        self.rule_templates = {
            RuleType.SECURITY: self._security_rule_template,
            RuleType.BACKUP: self._backup_rule_template,
            RuleType.OPTIMIZATION: self._optimization_rule_template,
            RuleType.GOVERNANCE: self._governance_rule_template,
            RuleType.WORKFLOW: self._workflow_rule_template,
            RuleType.SYMBOLIC: self._symbolic_rule_template,
            RuleType.TRINITY: self._trinity_rule_template
        }
    
    async def generate_security_rule(self, security_gap: Dict[str, Any]) -> GeneratedRule:
        """Generate security rule based on detected gap"""
        context = RuleContext(
            trigger_event=f"Security gap detected: {security_gap['type']}",
            risk_level=security_gap.get('risk_level', 'medium'),
            detection_method="automated_security_scan",
            affected_systems=security_gap.get('affected_systems', []),
            mitigation_strategy=security_gap.get('mitigation', 'implement_security_controls'),
            justification=f"Security vulnerability detected in {security_gap.get('location', 'unknown')}",
            linked_rules=["/rules/security_baseline.rule.yaml"],
            collaboration_agents=["SecurityGuardianAgent", "ComplianceAgent"]
        )
        
        rule = await self._generate_rule(
            rule_type=RuleType.SECURITY,
            title=f"Auto-Security: {security_gap['type']} Protection",
            description=f"Automatically generated security rule for {security_gap['type']} vulnerability",
            context=context
        )
        
        return rule
    
    async def generate_backup_rule(self, backup_gap: Dict[str, Any]) -> GeneratedRule:
        """Generate backup rule for unprotected assets"""
        context = RuleContext(
            trigger_event=f"Backup gap detected: {backup_gap['asset_type']}",
            risk_level="high",
            detection_method="file_system_analysis",
            affected_systems=backup_gap.get('affected_files', []),
            mitigation_strategy="implement_automated_backup",
            justification="No existing backup system found; MCP tools detected risk vectors",
            linked_rules=["/rules/backup_safety.rule.yaml"],
            collaboration_agents=["FileIntelligenceAgent", "BackupAgent"]
        )
        
        rule = await self._generate_rule(
            rule_type=RuleType.BACKUP,
            title="Auto-Backup: Critical File Protection",
            description="Automatically generated backup rule for unprotected critical files",
            context=context
        )
        
        return rule
    
    async def generate_optimization_rule(self, performance_issue: Dict[str, Any]) -> GeneratedRule:
        """Generate optimization rule for performance issues"""
        context = RuleContext(
            trigger_event=f"Performance degradation: {performance_issue['metric']}",
            risk_level="medium",
            detection_method="performance_monitoring",
            affected_systems=performance_issue.get('affected_processes', []),
            mitigation_strategy="optimize_resource_usage",
            justification=f"Performance degradation detected: {performance_issue.get('details', 'unknown')}",
            linked_rules=["/rules/performance_baseline.rule.yaml"],
            collaboration_agents=["PerformanceAgent", "OptimizationAgent"]
        )
        
        rule = await self._generate_rule(
            rule_type=RuleType.OPTIMIZATION,
            title=f"Auto-Optimize: {performance_issue['metric']} Enhancement",
            description=f"Performance optimization rule for {performance_issue['metric']}",
            context=context
        )
        
        return rule
    
    async def generate_trinity_coordination_rule(self, coordination_issue: Dict[str, Any]) -> GeneratedRule:
        """Generate trinity coordination rule"""
        context = RuleContext(
            trigger_event=f"Trinity coordination issue: {coordination_issue['type']}",
            risk_level="high",
            detection_method="trinity_monitoring",
            affected_systems=coordination_issue.get('affected_nodes', []),
            mitigation_strategy="rebalance_trinity_roles",
            justification=f"Trinity imbalance detected: {coordination_issue.get('description', 'unknown')}",
            linked_rules=["/rules/trinity_governance/coordination.rule.yaml"],
            collaboration_agents=["TrinityCoordinator", "ConsensusAgent"]
        )
        
        rule = await self._generate_rule(
            rule_type=RuleType.TRINITY,
            title=f"Auto-Trinity: {coordination_issue['type']} Coordination",
            description=f"Trinity coordination rule for {coordination_issue['type']} rebalancing",
            context=context
        )
        
        return rule
    
    async def _generate_rule(self, rule_type: RuleType, title: str, description: str, context: RuleContext) -> GeneratedRule:
        """Generate a rule using appropriate template"""
        rule_id = f"auto_generated_{rule_type.value}_{int(time.time())}"
        
        # Generate rule content using template
        template_func = self.rule_templates[rule_type]
        rule_content = await template_func(context)
        
        # Create rule object
        rule = GeneratedRule(
            rule_id=rule_id,
            author_agent=self.agent_id,
            title=title,
            description=description,
            rule_type=rule_type,
            priority=RulePriority.HIGH,
            content=rule_content,
            context=context,
            validation_criteria=self._generate_validation_criteria(rule_type, context),
            evolution_triggers=self._generate_evolution_triggers(rule_type, context),
            created_at=datetime.now(timezone.utc),
            version="1.0"
        )
        
        # Save rule to file
        await self._save_rule_to_file(rule)
        
        # Log creation
        await self._log_rule_creation(rule)
        
        return rule
    
    async def _security_rule_template(self, context: RuleContext) -> str:
        """Generate security rule content"""
        return f"""
# Security Rule Implementation

## Threat Detection
- **Risk Level**: {context.risk_level}
- **Affected Systems**: {', '.join(context.affected_systems)}
- **Detection Method**: {context.detection_method}

## Mitigation Strategy
{context.mitigation_strategy}

## Security Controls
- Implement access controls
- Enable audit logging
- Apply encryption where applicable
- Regular security assessments

## Monitoring
- Continuous threat monitoring
- Automated alert generation
- Regular compliance checks

## Response Protocol
1. Immediate threat containment
2. Impact assessment
3. Remediation implementation
4. Lessons learned documentation
"""
    
    async def _backup_rule_template(self, context: RuleContext) -> str:
        """Generate backup rule content"""
        return f"""
# Backup Rule Implementation

## Backup Strategy
- **Target Systems**: {', '.join(context.affected_systems)}
- **Backup Frequency**: Daily incremental, weekly full
- **Retention Policy**: 30 days incremental, 1 year full

## Automated Backup Process
1. Identify critical files and configurations
2. Create encrypted backup archives
3. Store in multiple locations (local + remote)
4. Verify backup integrity
5. Test restore procedures monthly

## Recovery Procedures
- Document restore steps
- Maintain recovery time objectives (RTO)
- Regular disaster recovery testing

## Monitoring and Alerts
- Backup success/failure notifications
- Storage capacity monitoring
- Backup verification checks
"""
    
    async def _optimization_rule_template(self, context: RuleContext) -> str:
        """Generate optimization rule content"""
        return f"""
# Performance Optimization Rule

## Performance Metrics
- **Target Systems**: {', '.join(context.affected_systems)}
- **Optimization Focus**: {context.mitigation_strategy}

## Optimization Strategies
1. Resource usage analysis
2. Bottleneck identification
3. Code/process optimization
4. Caching implementation
5. Load balancing

## Monitoring and Baselines
- Establish performance baselines
- Continuous monitoring
- Threshold-based alerting
- Regular performance reviews

## Implementation Steps
1. Analyze current performance
2. Identify optimization opportunities
3. Implement improvements
4. Measure and validate results
5. Document best practices
"""
    
    async def _governance_rule_template(self, context: RuleContext) -> str:
        """Generate governance rule content"""
        return f"""
# Governance Rule Implementation

## Governance Framework
- **Scope**: {', '.join(context.affected_systems)}
- **Compliance Requirements**: {context.mitigation_strategy}

## Policy Implementation
1. Define clear policies and procedures
2. Establish approval workflows
3. Implement access controls
4. Regular policy reviews

## Compliance Monitoring
- Automated compliance checks
- Regular audit procedures
- Exception handling processes
- Corrective action tracking

## Reporting and Documentation
- Regular compliance reports
- Policy violation tracking
- Training and awareness programs
"""
    
    async def _workflow_rule_template(self, context: RuleContext) -> str:
        """Generate workflow rule content"""
        return f"""
# Workflow Optimization Rule

## Workflow Analysis
- **Target Processes**: {', '.join(context.affected_systems)}
- **Optimization Strategy**: {context.mitigation_strategy}

## Process Improvement
1. Map current workflow
2. Identify inefficiencies
3. Design optimized process
4. Implement automation
5. Monitor and refine

## Automation Opportunities
- Repetitive task automation
- Decision point optimization
- Integration improvements
- Error reduction strategies

## Success Metrics
- Process completion time
- Error rates
- Resource utilization
- User satisfaction
"""
    
    async def _symbolic_rule_template(self, context: RuleContext) -> str:
        """Generate symbolic rule content"""
        return f"""
# Symbolic Evolution Rule

## Symbolic Pattern Recognition
- **Pattern Type**: {context.trigger_event}
- **Archetypal Alignment**: {context.mitigation_strategy}

## Delta Function Implementation
1. Pattern detection and analysis
2. Symbolic transformation mapping
3. Evolution pathway identification
4. Consciousness level assessment

## Narrative Integration
- Story coherence maintenance
- Identity evolution tracking
- Symbolic consistency validation
- Archetypal alignment verification

## Evolution Triggers
- Pattern complexity thresholds
- Symbolic emergence events
- Consciousness level shifts
- Narrative coherence breaks
"""
    
    async def _trinity_rule_template(self, context: RuleContext) -> str:
        """Generate trinity coordination rule content"""
        return f"""
# Trinity Coordination Rule

## Trinity Node Rebalancing
- **Affected Nodes**: {', '.join(context.affected_systems)}
- **Coordination Issue**: {context.trigger_event}

## Role Redistribution Strategy
1. Assess current node performance
2. Identify imbalance causes
3. Redistribute roles and responsibilities
4. Implement coordination protocols
5. Monitor harmony metrics

## Consensus Mechanisms
- Decision-making protocols
- Conflict resolution procedures
- Collaboration enhancement
- Communication optimization

## Harmony Metrics
- Role efficiency scores
- Collaboration effectiveness
- Consensus achievement rate
- System-wide coherence
"""
    
    def _generate_validation_criteria(self, rule_type: RuleType, context: RuleContext) -> List[str]:
        """Generate validation criteria for rule"""
        base_criteria = [
            "Rule implementation successful",
            "No negative side effects observed", 
            "Performance impact within acceptable limits",
            "Compliance requirements satisfied"
        ]
        
        type_specific = {
            RuleType.SECURITY: [
                "Security vulnerabilities addressed",
                "No new security gaps introduced",
                "Audit trail properly maintained"
            ],
            RuleType.BACKUP: [
                "Backup integrity verified",
                "Recovery procedures tested",
                "Storage requirements met"
            ],
            RuleType.TRINITY: [
                "Trinity harmony restored",
                "Node coordination improved",
                "Consensus mechanisms functional"
            ]
        }
        
        return base_criteria + type_specific.get(rule_type, [])
    
    def _generate_evolution_triggers(self, rule_type: RuleType, context: RuleContext) -> List[str]:
        """Generate evolution triggers for rule"""
        base_triggers = [
            "Performance degradation detected",
            "New requirements identified",
            "Technology stack changes",
            "Regulatory updates"
        ]
        
        type_specific = {
            RuleType.SECURITY: [
                "New threat vectors identified",
                "Security standard updates",
                "Compliance requirement changes"
            ],
            RuleType.SYMBOLIC: [
                "Symbolic pattern evolution",
                "Consciousness level changes",
                "Archetypal alignment shifts"
            ],
            RuleType.TRINITY: [
                "Trinity role evolution",
                "Coordination pattern changes",
                "Harmony metric degradation"
            ]
        }
        
        return base_triggers + type_specific.get(rule_type, [])
    
    async def _save_rule_to_file(self, rule: GeneratedRule):
        """Save rule to .mdc file"""
        rule_filename = f"{rule.rule_id}.mdc"
        rule_path = self.rules_path / rule_filename
        
        # Generate .mdc content
        mdc_content = f"""---
id: {rule.rule_id}
description: {rule.description}
authored_by: {rule.author_agent}
justification: "{rule.context.justification}"
linked_to: {rule.context.linked_rules}
collaboration_agents: {rule.context.collaboration_agents}
type: {rule.rule_type.value}
priority: {rule.priority.value}
version: {rule.version}
created_at: {rule.created_at.isoformat()}
risk_level: {rule.context.risk_level}
---

# {rule.title}

## Auto-Generated Context
- **Agent**: {rule.author_agent}
- **Detection**: {rule.context.detection_method}
- **Risk Level**: {rule.context.risk_level}
- **Mitigation**: {rule.context.mitigation_strategy}
- **Trigger Event**: {rule.context.trigger_event}

{rule.content}

## Validation Criteria
{chr(10).join('- ' + criterion for criterion in rule.validation_criteria)}

## Evolution Triggers
{chr(10).join('- ' + trigger for trigger in rule.evolution_triggers)}

## Collaboration Notes
This rule was generated in collaboration with: {', '.join(rule.context.collaboration_agents)}

## Linked Rules
{chr(10).join('- ' + linked_rule for linked_rule in rule.context.linked_rules)}
"""
        
        # Write to file with UTF-8 encoding
        with open(rule_path, 'w', encoding='utf-8') as f:
            f.write(mdc_content)
        
        logger.info(f"📝 Rule saved: {rule_path}")
    
    async def _log_rule_creation(self, rule: GeneratedRule):
        """Log rule creation for audit trail"""
        log_entry = {
            "timestamp": rule.created_at.isoformat(),
            "event": "rule_created",
            "rule_id": rule.rule_id,
            "author_agent": rule.author_agent,
            "rule_type": rule.rule_type.value,
            "trigger_event": rule.context.trigger_event,
            "risk_level": rule.context.risk_level,
            "affected_systems": rule.context.affected_systems
        }
        
        # Append to creation log
        log_path = self.vanta_path / "runtime" / "rule_creation_log.jsonl"
        with open(log_path, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')

class CollaborativeRuleEngine:
    """Engine for collaborative rule authoring between agents"""
    
    def __init__(self, vanta_path: Path):
        self.vanta_path = vanta_path
        self.collaboration_queue = []
    
    async def propose_collaborative_rule(self, 
                                       initiating_agent: str,
                                       collaborating_agents: List[str],
                                       rule_proposal: Dict[str, Any]) -> str:
        """Propose a rule for collaborative authoring"""
        proposal_id = f"collab_rule_{int(time.time())}"
        
        proposal = {
            "proposal_id": proposal_id,
            "initiating_agent": initiating_agent,
            "collaborating_agents": collaborating_agents,
            "rule_proposal": rule_proposal,
            "status": "pending_collaboration",
            "created_at": datetime.now(timezone.utc).isoformat(),
            "contributions": {},
            "consensus_required": len(collaborating_agents) >= 2
        }
        
        # Save proposal
        proposal_path = self.vanta_path / "rules" / "collaboration" / f"{proposal_id}.yaml"
        proposal_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(proposal_path, 'w') as f:
            yaml.dump(proposal, f, default_flow_style=False)
        
        # Notify collaborating agents via A2A
        await self._notify_collaborators(proposal)
        
        return proposal_id
    
    async def contribute_to_rule(self, 
                               proposal_id: str,
                               contributing_agent: str,
                               contribution: Dict[str, Any]) -> bool:
        """Add contribution to collaborative rule"""
        proposal_path = self.vanta_path / "rules" / "collaboration" / f"{proposal_id}.yaml"
        
        if not proposal_path.exists():
            return False
        
        # Load proposal
        with open(proposal_path, 'r') as f:
            proposal = yaml.safe_load(f)
        
        # Add contribution
        proposal["contributions"][contributing_agent] = {
            "contribution": contribution,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        # Check if collaboration is complete
        if len(proposal["contributions"]) >= len(proposal["collaborating_agents"]):
            proposal["status"] = "ready_for_synthesis"
            await self._synthesize_collaborative_rule(proposal)
        
        # Save updated proposal
        with open(proposal_path, 'w') as f:
            yaml.dump(proposal, f, default_flow_style=False)
        
        return True
    
    async def _notify_collaborators(self, proposal: Dict[str, Any]):
        """Notify collaborating agents about rule proposal"""
        # This would integrate with A2A messaging system
        for agent in proposal["collaborating_agents"]:
            message = {
                "sender_id": proposal["initiating_agent"],
                "recipient_id": agent,
                "message_type": "collaboration_request",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "payload": {
                    "proposal_id": proposal["proposal_id"],
                    "rule_type": proposal["rule_proposal"].get("type", "unknown"),
                    "description": proposal["rule_proposal"].get("description", "")
                }
            }
            
            # Save to A2A outbox
            message_path = self.vanta_path / "a2a" / "outbox" / f"collab_{proposal['proposal_id']}_{agent}.yaml"
            with open(message_path, 'w') as f:
                yaml.dump(message, f, default_flow_style=False)
    
    async def _synthesize_collaborative_rule(self, proposal: Dict[str, Any]):
        """Synthesize final rule from all contributions"""
        # This would use advanced synthesis logic to combine contributions
        synthesized_rule = {
            "base_proposal": proposal["rule_proposal"],
            "contributions": proposal["contributions"],
            "synthesis_method": "weighted_consensus",
            "final_rule": "synthesized_content"  # Would be actual synthesis
        }
        
        # Create final rule using synthesis
        # This would integrate with AgentRuleGenerator to create the final .mdc file

# Factory functions
def create_rule_generator(agent_id: str, vanta_path: Path) -> AgentRuleGenerator:
    """Create rule generator for an agent"""
    return AgentRuleGenerator(agent_id, vanta_path)

def create_collaborative_engine(vanta_path: Path) -> CollaborativeRuleEngine:
    """Create collaborative rule engine"""
    return CollaborativeRuleEngine(vanta_path)

if __name__ == "__main__":
    async def demo_rule_generation():
        """Demo the agent rule generation system"""
        print("📝 Agent-Generated MDC Rules System Demo")
        print("=" * 50)
        
        vanta_path = Path(".vanta")
        vanta_path.mkdir(exist_ok=True)
        
        # Create rule generator for a security agent
        generator = create_rule_generator("SecurityGuardianAgent", vanta_path)
        
        # Generate a security rule
        security_gap = {
            "type": "unencrypted_secrets",
            "risk_level": "high",
            "affected_systems": ["config/secrets.yaml", ".env"],
            "location": "configuration files",
            "mitigation": "implement_vault_encryption"
        }
        
        security_rule = await generator.generate_security_rule(security_gap)
        print(f"✅ Generated security rule: {security_rule.rule_id}")
        
        # Generate a backup rule
        backup_gap = {
            "asset_type": "critical_configs",
            "affected_files": ["agent_core/", "vanta_core/"],
            "risk_level": "medium"
        }
        
        backup_rule = await generator.generate_backup_rule(backup_gap)
        print(f"✅ Generated backup rule: {backup_rule.rule_id}")
        
        # Generate trinity coordination rule
        coordination_issue = {
            "type": "role_imbalance",
            "affected_nodes": ["cube_planner", "dodec_executor"],
            "description": "Planner overloaded, executor underutilized"
        }
        
        trinity_rule = await generator.generate_trinity_coordination_rule(coordination_issue)
        print(f"✅ Generated trinity rule: {trinity_rule.rule_id}")
        
        print(f"\n📋 Total rules generated: 3")
        print(f"📁 Rules saved to: {generator.rules_path}")
    
    asyncio.run(demo_rule_generation())