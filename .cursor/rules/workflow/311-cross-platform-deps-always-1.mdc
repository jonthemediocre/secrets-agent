---
description: null
globs: null
alwaysApply: true
type: always
migrated: true
migration_date: '2025-06-07T14:32:13.443182'
---

# RULE TYPE: Best Practice
# FILE PATTERNS: requirements.in, requirements.txt, pyproject.toml

# Cross-Platform Dependency Management

## Problem

Dependency lock files (like `requirements.txt` generated by `pip-compile` or `poetry.lock` by Poetry) created on one operating system (e.g., Windows) might include packages or specific versions that are only compatible with that OS (e.g., `pywin32`). Attempting to install from this lock file on a different OS (e.g., Linux/WSL) will fail.

## Rationale

Ensuring that dependency resolution works reliably across all target development and deployment environments is crucial for avoiding installation errors and maintaining consistency.

## Recommended Solutions

1.  **Environment Markers (Preferred)**:
    *   Define platform-specific dependencies directly in your source file (`requirements.in` or `pyproject.toml`) using environment markers. `pip-compile` and other modern tools will respect these markers and generate a lock file that correctly handles different platforms during installation.
    *   **Example (`requirements.in`):**
        ```
        # Base requirements
        requests
        portalocker

        # Windows specific
        pywin32 ; sys_platform == 'win32'

        # Linux specific (example)
        # some_linux_package ; sys_platform == 'linux'
        ```
    *   **Example (`pyproject.toml` with Poetry/PDM):**
        ```toml
        [tool.poetry.dependencies]
        python = "^3.9"
        requests = "*"
        portalocker = "*"
        pywin32 = { version = "*", platform = "win32" }
        # some_linux_package = { version = "*", platform = "linux" }
        ```
    *   When `pip install -r requirements.txt` (or `poetry install`, `pdm install`) is run, it will evaluate the markers and only install packages appropriate for the current OS.

2.  **Separate Lock Files (Less Ideal for Simple Cases)**:
    *   Generate and maintain separate lock files for each target platform (e.g., `requirements-windows.txt`, `requirements-linux.txt`).
    *   This requires running the compilation command (`pip-compile`) on each target platform or using cross-compilation tools/containers.
    *   Requires specific installation commands based on the environment (e.g., `pip install -r requirements-linux.txt`). Use only if environment markers are insufficient for complex cases.

3.  **Compile on Target/Container**:
    *   Always run the dependency compilation step (`pip-compile`, `poetry lock`, `pdm lock`) *on the target operating system* or within a Docker container that mirrors the target deployment environment. This ensures the generated lock file is inherently compatible.

## Best Practices

*   **Favor Environment Markers:** They are the standard, most robust way to handle OS-specific Python dependencies within a single set of requirement files.
*   **Check Generated Files:** If generating lock files on one OS but deploying/developing on another, manually review the lock file for platform-specific packages like `pywin32` if not using environment markers.
*   **Document Your Strategy:** Clearly state the chosen dependency management approach for cross-platform support in your project's `README.md` or `CONTRIBUTING.md`.
*   **Test Installation:** Ensure your CI/CD pipeline (if applicable) tests the installation process on all target platforms.
