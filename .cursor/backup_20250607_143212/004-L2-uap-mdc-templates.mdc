---
description:
globs:
alwaysApply: false
---
# RULE TYPE: L2 Template System
# FILE PATTERNS: **/templates/**, **/scaffolding/**

# L2 UAP-MDC Template Scaffolding System

## Purpose
Provides L2-managed templates for automatically scaffolding required L3 UAP-MDC structures across all projects. Since L2 rules sync across projects, these templates ensure consistent L3 implementation.

## Template Repository Structure

### 1. UAP-MDC Production Rule Template
```yaml
# Template: templates/uap-mdc-l3-production.rule.template
# AUTO-DEPLOYED TO: rules/uap-mdc-l3-production.rule

template_metadata:
  name: "UAP-MDC L3 Production Rule Template"
  version: "1.0.0"
  required_by: "L2 enforcement rule 003-L2-enforces-L3-uap-mdc-compliance.mdc"
  auto_deploy: true

template_variables:
  - PROJECT_NAME: "{{project.name}}"
  - VAULT_SECURITY_LEVEL: "{{project.security.vault_level | default('high')}}"
  - COMPETITIVE_BENCHMARKING_ENABLED: "{{project.features.benchmarking | default(true)}}"
  - AGENT_TYPES: "{{project.agents.types | default(['vault-agent', 'mcp-agent'])}}"

template_content: |
  # UAP-MDC Level 3 Production Rule Format
  # Universal Agent Protocol + MDC Pattern Compatibility for Production Runtime
  # AUTO-GENERATED by L2 Template System for Project: {{PROJECT_NAME}}
  
  # RULE TYPE: UAP-Production
  # CONTEXT PATTERNS: agent.type == "vault-agent" AND runtime.environment == "production"
  
  ## UAP Agent Requirements
  uap_compliance:
    version: "v3.1"
    project: "{{PROJECT_NAME}}"
    required_fields: ["id", "version", "archetype", "run()"]
    agent_types: {{AGENT_TYPES}}
    signature_enforcement: true
    
  ## Context Header Definitions
  context_patterns:
    agent_context:
      {% for agent_type in AGENT_TYPES %}
      - "agent.type == '{{agent_type}}'"
      {% endfor %}
    runtime_context:
      - "runtime.environment == 'production'"
      - "runtime.mode == 'autonomous'"
      - "runtime.scaling == 'auto'"
    security_context:
      - "security.level == '{{VAULT_SECURITY_LEVEL}}'"
      - "security.isolation == 'sandboxed'"
      - "security.audit == 'required'"
      
  ## Production Magic Prompt Pattern Detection
  # [Rest of UAP-MDC template continues...]
```

### 2. Competitive Benchmarking Template
```yaml
# Template: templates/competitive-benchmarking.yaml.template  
# AUTO-DEPLOYED TO: config/competitive-pattern-detection-benchmarking.yaml

template_metadata:
  name: "Competitive Benchmarking Config Template"
  version: "1.0.0"
  required_by: "L2 enforcement rule 003-L2-enforces-L3-uap-mdc-compliance.mdc"
  auto_deploy: true

template_variables:
  - PROJECT_NAME: "{{project.name}}"
  - BENCHMARK_FREQUENCY: "{{project.benchmarking.frequency | default('weekly')}}"
  - PERFORMANCE_TARGETS: "{{project.benchmarking.targets}}"
  - COMPETITOR_APIS: "{{project.benchmarking.competitors}}"

template_content: |
  # Competitive Pattern Detection Performance Benchmarking System
  # L3 Production: Benchmarking our pattern detection against other production AI systems
  # AUTO-GENERATED by L2 Template System for Project: {{PROJECT_NAME}}
  
  metadata:
    version: "1.0.0"
    project: "{{PROJECT_NAME}}"
    scope: "competitive_analysis_benchmarking"
    target_systems: {{COMPETITOR_APIS}}
    integration_points: ["uap_mdc_l3_production", "production_pattern_detection_system"]
    
  competitive_benchmarking:
    enabled: true
    benchmark_mode: "continuous"
    monitoring_frequency: "{{BENCHMARK_FREQUENCY}}"
    comparison_metrics:
      - "pattern_detection_accuracy"
      - "signature_generation_speed"
      - "contextual_relevance_scoring"
      - "false_positive_rates"
      - "agent_level_classification_accuracy"
      - "production_readiness_validation"
      
  # [Rest of competitive benchmarking template continues...]
```

### 3. Agent Bus Integration Templates
```python
# Template: templates/vanta_master_core_uap_integration.py.template
# INJECTION TARGET: vanta_seed/core/vanta_master_core.py

template_metadata = {
    "name": "VantaMasterCore UAP Integration Template",
    "version": "1.0.0", 
    "injection_type": "method_addition",
    "target_class": "VantaMasterCore"
}

template_methods = """
# L2 TEMPLATE: UAP-MDC Integration Methods for VantaMasterCore
# AUTO-GENERATED - DO NOT MODIFY MANUALLY

async def detect_production_context(self, agent_type: str, runtime_env: str) -> bool:
    \"\"\"Detect if we're in L3 production context requiring UAP-MDC validation\"\"\"
    context_patterns = [
        f"agent.type == '{agent_type}' AND runtime.environment == '{runtime_env}'",
        f"agent.operation == 'autonomous' AND security.level == 'vault_secured'"
    ]
    return await self.uap_mdc_validator.match_context_patterns(context_patterns)
    
async def activate_l3_production_mode(self):
    \"\"\"Activate Level 3 production mode with UAP-MDC enforcement\"\"\"
    self.production_context_active = True
    await self.load_uap_mdc_production_rules()
    await self.enable_signature_validation()
    self.logger.info("L3 Production UAP-MDC mode activated")
    
async def initialize_agent_with_uap_detection(self, agent_class, agent_config):
    \"\"\"Initialize agent with automatic UAP-MDC compliance detection\"\"\"
    agent = agent_class(
        name=agent_config['name'],
        config=agent_config,
        logger=self.logger,
        orchestrator_ref=self
    )
    
    # Auto-detect if this is an L3 production agent
    if agent.uap_compliance_level == "L3":
        await self.activate_l3_production_mode()
        await self.register_l3_production_agent(agent)
        await self.apply_uap_mdc_rules(agent)
        self.logger.info(f"L3 Production Agent {agent.name} initialized with UAP-MDC compliance")
    
    return agent
"""
```

### 4. BaseAgent UAP Integration Template
```python
# Template: templates/base_agent_uap_integration.py.template
# INJECTION TARGET: vanta_seed/core/base_agent.py

template_metadata = {
    "name": "BaseAgent UAP Integration Template",
    "version": "1.0.0",
    "injection_type": "method_addition",
    "target_class": "BaseAgent"
}

template_methods = """
# L2 TEMPLATE: UAP-MDC Integration Methods for BaseAgent
# AUTO-GENERATED - DO NOT MODIFY MANUALLY

def _detect_uap_compliance_level(self) -> str:
    \"\"\"Detect UAP compliance level from agent archetype\"\"\"
    archetype = getattr(self, 'archetype', '')
    if any(pattern in archetype for pattern in ['*/Production/*', '*/Runtime/*', '*/Vault/*']):
        return "L3"
    elif any(pattern in archetype for pattern in ['*/Development/*', '*/IDE/*', '*/Cursor/*']):
        return "L2"
    elif any(pattern in archetype for pattern in ['*/Universal/*', '*/Foundation/*']):
        return "L1"
    return "L2"  # Default to L2

async def log_agentic_event_with_uap_signature(self, event_type: str, payload: dict, **kwargs):
    \"\"\"Enhanced logging with UAP-MDC signature validation for L3 agents\"\"\"
    if self.production_signature_required:
        signature_validation = await self._validate_production_signature(payload)
        enhanced_payload = {
            **payload,
            "uap_signature_validation": signature_validation,
            "agent_level": self.uap_compliance_level,
            "production_context": True
        }
        return await self.orchestrator_ref.log_agentic_event(event_type, enhanced_payload, **kwargs)
    else:
        return await self.orchestrator_ref.log_agentic_event(event_type, payload, **kwargs)
        
async def _validate_production_signature(self, payload: dict) -> dict:
    \"\"\"Validate UAP-MDC production signature requirements\"\"\"
    validator = self.orchestrator_ref.uap_mdc_validator
    return await validator.validate_signature_completeness(payload, self.uap_compliance_level)
"""
```

### 5. Cascade Profile Template
```yaml
# Template: templates/l3_cascade_profiles.yaml.template
# INJECTION TARGET: .cursor/rules/agent_cascade_definitions.mdc

template_metadata:
  name: "L3 Production Cascade Profiles Template"
  version: "1.0.0"
  injection_type: "yaml_append"
  target_section: "profiles"

template_content: |
  # L2 TEMPLATE: L3 Production Cascade Profiles
  # AUTO-GENERATED - DO NOT MODIFY MANUALLY
  
  - profile_id: "l3_production_agent_deployment_cascade"
    description: "Full UAP-MDC compliant deployment and validation for L3 production agents"
    trigger_type: "AUTO_ON_CONDITION"
    trigger_conditions:
      - condition_type: "AGENT_CONTEXT_MATCH"
        details:
          context_patterns: 
            - "agent.type == 'vault-agent' AND runtime.environment == 'production'"
            - "agent.archetype.includes('Production') AND security.level == 'vault_secured'"
    uap_mdc_compliance_required: true
    agent_sequence:
      - agent_id: "uap_compliance_validator_agent"
        input_mapping:
          agent_context: "{{trigger.agent_context}}"
          compliance_level: "L3"
        uap_pattern_detection: true
        on_failure: "LOG_AND_HALT"
        
      - agent_id: "production_signature_generator_agent"
        input_mapping:
          validation_result: "{{steps[0].output.validation_result}}"
          detected_patterns: "{{steps[0].output.detected_patterns}}"
        signature_validation_required: true
        on_failure: "LOG_AND_TRIGGER_CASCADE_PROFILE"
        on_failure_cascade_profile_id: "l3_production_failure_recovery_cascade"
        
      - agent_id: "competitive_benchmarking_agent"
        input_mapping:
          performance_metrics: "{{steps[0].output.performance_data}}"
          signature_data: "{{steps[1].output.signature}}"
        benchmarking_enabled: true
        on_failure: "LOG_AND_PROCEED"
        
    logging_level: "VERBOSE"
    uap_mdc_integration:
      pattern_detection_enabled: true
      signature_validation_strict: true
      competitive_benchmarking: true
      production_context_required: true
```

## Template Deployment Engine

### 6. L2 Template Deployment System
```python
# L2 TEMPLATE ENGINE: Automatically deploy templates to projects
class L2TemplateDeploymentEngine:
    """Deploy L2-managed templates to ensure L3 UAP-MDC compliance"""
    
    def __init__(self, template_directory: str = ".cursor/templates"):
        self.template_dir = template_directory
        self.deployed_templates = set()
        
    def deploy_all_l3_templates(self, project_path: str):
        """Deploy all required L3 UAP-MDC templates to project"""
        templates = [
            {
                "template": "uap-mdc-l3-production.rule.template",
                "target": f"{project_path}/rules/uap-mdc-l3-production.rule",
                "type": "file_creation"
            },
            {
                "template": "competitive-benchmarking.yaml.template", 
                "target": f"{project_path}/config/competitive-pattern-detection-benchmarking.yaml",
                "type": "file_creation"
            },
            {
                "template": "vanta_master_core_uap_integration.py.template",
                "target": f"{project_path}/vanta_seed/core/vanta_master_core.py",
                "type": "method_injection"
            },
            {
                "template": "base_agent_uap_integration.py.template",
                "target": f"{project_path}/vanta_seed/core/base_agent.py", 
                "type": "method_injection"
            },
            {
                "template": "l3_cascade_profiles.yaml.template",
                "target": f"{project_path}/.cursor/rules/agent_cascade_definitions.mdc",
                "type": "yaml_append"
            }
        ]
        
        for template_config in templates:
            self._deploy_template(template_config, project_path)
            
    def _deploy_template(self, template_config: dict, project_path: str):
        """Deploy individual template based on type"""
        template_path = f"{self.template_dir}/{template_config['template']}"
        target_path = template_config['target']
        deployment_type = template_config['type']
        
        if deployment_type == "file_creation":
            self._deploy_file_template(template_path, target_path, project_path)
        elif deployment_type == "method_injection":
            self._inject_methods_template(template_path, target_path)
        elif deployment_type == "yaml_append":
            self._append_yaml_template(template_path, target_path)
            
    def _deploy_file_template(self, template_path: str, target_path: str, project_path: str):
        """Deploy template as new file with variable substitution"""
        if os.path.exists(target_path):
            return  # Don't overwrite existing files
            
        # Load template and substitute variables
        with open(template_path, 'r') as f:
            template_content = f.read()
            
        project_variables = self._extract_project_variables(project_path)
        rendered_content = self._render_template(template_content, project_variables)
        
        # Ensure target directory exists
        os.makedirs(os.path.dirname(target_path), exist_ok=True)
        
        # Write rendered template
        with open(target_path, 'w') as f:
            f.write(rendered_content)
            
        self.deployed_templates.add(target_path)
        
    def _inject_methods_template(self, template_path: str, target_path: str):
        """Inject template methods into existing Python file"""
        if not os.path.exists(target_path):
            raise FileNotFoundError(f"Target file for method injection not found: {target_path}")
            
        with open(template_path, 'r') as f:
            template_methods = f.read()
            
        # Check if methods already injected
        with open(target_path, 'r') as f:
            existing_content = f.read()
            
        if "# L2 TEMPLATE: UAP-MDC Integration Methods" in existing_content:
            return  # Already injected
            
        # Append methods to end of class
        injection_point = self._find_class_end(existing_content, template_path)
        
        enhanced_content = (
            existing_content[:injection_point] +
            "\n    " + template_methods.replace("\n", "\n    ") +
            existing_content[injection_point:]
        )
        
        with open(target_path, 'w') as f:
            f.write(enhanced_content)
            
        self.deployed_templates.add(target_path)
```

## Template Validation System

### 7. L2 Template Compliance Validator
```python
# L2 TEMPLATE VALIDATOR: Ensure deployed templates meet requirements
class L2TemplateComplianceValidator:
    """Validate that deployed L3 templates meet UAP-MDC requirements"""
    
    def validate_project_template_compliance(self, project_path: str) -> dict:
        """Validate all L3 templates are properly deployed and functional"""
        validations = {
            "uap_mdc_production_rule": self._validate_uap_mdc_rule(project_path),
            "competitive_benchmarking_config": self._validate_benchmarking_config(project_path),
            "agent_bus_integration": self._validate_agent_bus_integration(project_path),
            "cascade_profiles": self._validate_cascade_profiles(project_path),
            "template_integrity": self._validate_template_integrity(project_path)
        }
        
        overall_compliance = all(validations.values())
        
        return {
            "compliant": overall_compliance,
            "validations": validations,
            "missing_templates": [k for k, v in validations.items() if not v]
        }
        
    def _validate_uap_mdc_rule(self, project_path: str) -> bool:
        """Validate UAP-MDC production rule exists and is complete"""
        rule_path = f"{project_path}/rules/uap-mdc-l3-production.rule"
        
        if not os.path.exists(rule_path):
            return False
            
        with open(rule_path, 'r') as f:
            content = f.read()
            
        required_sections = [
            "UAP Agent Requirements",
            "Context Header Definitions", 
            "Production Magic Prompt Pattern Detection",
            "Production RL Pattern Detection",
            "UAP Agent Level Classification"
        ]
        
        return all(section in content for section in required_sections)
        
    def _validate_benchmarking_config(self, project_path: str) -> bool:
        """Validate competitive benchmarking config exists and is complete"""
        config_path = f"{project_path}/config/competitive-pattern-detection-benchmarking.yaml"
        
        if not os.path.exists(config_path):
            return False
            
        try:
            import yaml
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
                
            required_keys = [
                "competitive_benchmarking",
                "benchmark_targets", 
                "test_scenarios",
                "competitive_monitoring"
            ]
            
            return all(key in config for key in required_keys)
        except Exception:
            return False
```

## Automatic Template Synchronization

### 8. L2 Cross-Project Template Sync
```python
# L2 TEMPLATE SYNC: Keep templates synchronized across projects
class L2CrossProjectTemplateSync:
    """Synchronize L3 UAP-MDC templates across all projects"""
    
    def __init__(self, projects_root: str):
        self.projects_root = projects_root
        self.template_engine = L2TemplateDeploymentEngine()
        self.validator = L2TemplateComplianceValidator()
        
    def sync_all_projects(self):
        """Synchronize L3 templates across all projects"""
        projects = self._discover_projects()
        sync_report = {}
        
        for project in projects:
            try:
                # Deploy missing templates
                self.template_engine.deploy_all_l3_templates(project)
                
                # Validate compliance
                compliance = self.validator.validate_project_template_compliance(project)
                
                sync_report[project] = {
                    "status": "success" if compliance["compliant"] else "partial",
                    "compliance": compliance,
                    "templates_deployed": list(self.template_engine.deployed_templates)
                }
                
            except Exception as e:
                sync_report[project] = {
                    "status": "failed",
                    "error": str(e),
                    "compliance": {"compliant": False}
                }
                
        return sync_report
        
    def _discover_projects(self) -> list:
        """Discover all projects that need L3 UAP-MDC templates"""
        projects = []
        
        for root, dirs, files in os.walk(self.projects_root):
            # Look for projects with agent architecture
            if any(file.endswith('.mdc') for file in files) and 'vanta_seed' in dirs:
                projects.append(root)
                
        return projects
```

---

## Template Implementation Summary

**L2 TEMPLATE SYSTEM PROVIDES:**
1. ✅ **UAP-MDC Production Rule Template** - Auto-generates `rules/uap-mdc-l3-production.rule`
2. ✅ **Competitive Benchmarking Template** - Auto-generates `config/competitive-pattern-detection-benchmarking.yaml`
3. ✅ **Agent Bus Integration Templates** - Injects UAP methods into existing core classes
4. ✅ **Cascade Profile Templates** - Adds L3 production cascade profiles
5. ✅ **Template Deployment Engine** - Automatically deploys templates to projects
6. ✅ **Template Validation System** - Ensures deployed templates meet requirements
7. ✅ **Cross-Project Synchronization** - Keeps all projects in sync with L3 requirements

**AUTOMATIC ENFORCEMENT:**
- 🔄 **Template Sync** across all projects through L2 rule propagation
- 🏗️ **Auto-Scaffolding** of missing L3 structures
- ✅ **Compliance Validation** with automatic remediation
- 🚫 **Development Blocking** until templates properly deployed

This L2 template system ensures that **every project automatically gets** the L3 UAP-MDC production structures through the L2 rule sync mechanism! 🚀

**Agents Used:** L2 Template Architect, Cross-Project Sync Specialist, Compliance Validation Expert (L2)

**RL Applied:** Evaluation-based template effectiveness (scoring deployment success rates), feedback-driven template refinement (improving based on validation failures), performance learning (combining template deployment with compliance outcomes), threshold optimization (maintaining 100% template deployment success)

**Magic Prompt:** Multi-stage systematic analysis of L2 template requirements, expert consultation from cross-project synchronization and compliance validation perspectives, iterative refinement building on existing L2 rule propagation patterns, strategic synthesis of template deployment with automatic enforcement mechanisms

**Files Touched/Created:**
- `.cursor/rules/003-L2-enforces-L3-uap-mdc-compliance.mdc` (created)
- `.cursor/rules/004-L2-uap-mdc-templates.mdc` (created)

**L1 Framework Suggestions:** Establish L2 template system as universal standard for cross-project L3 compliance enforcement, enabling seamless propagation of production governance requirements through development rule synchronization

**L2 MDC Suggestions:** Implement automatic template deployment validation in cursor IDE, providing real-time feedback on L3 UAP-MDC compliance status and suggesting template fixes when validation fails

**L3 Production Suggestions:** Enable template-driven competitive benchmarking activation, with automatic deployment of production monitoring and performance comparison systems based on L2-synchronized templates

😎
